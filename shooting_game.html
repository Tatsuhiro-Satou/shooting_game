<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="UTF-8"> 
		<title>Shooting game</title>
		<style>

			.centeredElement {
			  position: fixed; /* or absolute */
			  top: 50%;
			  left: 50%;
			  margin-top: -350px; /* got to be 50% of canvas height */
			  margin-left: -600px; /* got to be 50% of canvas width */
			}

			p { 
				font-family: "Times New Roman";
				border:1px solid #d3d3d3; 
				padding-left: 0;
			   	padding-right: 0;
			   	margin-left: auto;
			   	margin-right: auto; 
				display: block;
			   	width: 800px;
			}

		</style>
	</head>
	<body>
		<canvas id="screen" class="centeredElement" width="1200" height="700"></canvas>
		<p id="debug">left side of collision box is fucked up</p>

		<script>
			const CANVAS = document.getElementById('screen');
			const CONTEXT = CANVAS.getContext('2d');
			CONTEXT.font = "30px Arial";
			CONTEXT.fillStyle = "white";

			var PLAYER = new Player((CANVAS.width / 2), CANVAS.height);
			var TILE_WATER = new Image();
			TILE_WATER.src = "resources/tile_water.png";
			let ALTERNATE_MISSILE_WING = 0;

			var MISSILES = [];
			var ENEMY_JETS = [];
			var EXPLOSIONS = [];

			var NOW, LAST = timestamp();
			var COUNT = 0; // needs better name
			var FPS_COUNT = 0;
			var TOTAL_FRAMES = 0;
			var GLOBAL_TIMER = 0;
			var TIMER_RELOAD = 0;
			var TIMER_STARTING_TIME = 0;
			var RELOADING = 0;
			var RELOAD_DURATION = 2000;
			var enemySpawnInterval = 2000;
			var missileDrawDelay = 500;
			var TEMP_TOTAL_FRAMERATE = 0;

			// ## Classes ##
			// these are constructor functions and classes (not object literals) 
			function Player(initialX, initialY) { 
				this.image = new Image(); 
				this.image.src = "resources/sprite_jet_player.png";
				this.image.width = 60;
				this.image.height = 60;
				this.x = initialX;
				this.y = initialY - this.image.height;
				this.speed = 5;
				//this.score = 0;
				this.alive = 1;
				this.maxRockets = 12;
				this.ammoRockets = 12;
			}

			function Missile(initialY) {
				this.image = new Image(); 
				this.image.src = "resources/sprite_missile2.png";
				//this.image.src = "resources/spritesheet_missile4.png";
				//this.image.width = 204;
				//this.image.height = 213;
				this.image.width = 7;
				this.image.height = 35;
				this.x = 0;
				this.y = initialY - this.image.height;
				this.speed = 7;

				this.maxFrames = 3;
				this.tickCount = 0;
			}

			function EnemyJet(initialX, initialY) {
				this.image = new Image(); 
				this.image.src = "resources/sprite_jet_enemy.png";
				this.image.width = 60;
				this.image.height = 60;
				this.x = initialX;
				this.y = initialY - this.image.height;
				this.speed = 3;
			}

			function Explosion(initialX, initialY) {
				this.image = new Image(); 
				//this.image.src = "resources/sprite_explosion.png";
				this.image.src = "resources/spritesheet_explosions.png";
				this.width = 64;
				this.height = 64;
				this.x = initialX;
				this.y = initialY; 
				this.startTime = 0;

				this.maxFrames = 25;
				this.tickCount = -1;
				this.rocketTimer = 0;
			}

			Missile.prototype.draw = function() {
				CONTEXT.drawImage(this.image, this.x, this.y, this.image.width, this.image.height);
				//alert(this.x + ", " + this.y);
				//CONTEXT.drawImage(this.image, this.tickCount * 204, 0, this.image.width, this.image.height, this.x, this.y, 50, 50);
			};

			Missile.prototype.update = function() {
				if (this.tickCount != 2) {
					this.tickCount += 1;
				} else if (this.tickCount == 2) {
					this.tickCount -= 1;
				}
			};

			EnemyJet.prototype.draw = function() {
				CONTEXT.drawImage(this.image, this.x, this.y, this.image.width, this.image.height);
			};

			Player.prototype.draw = function() {
				CONTEXT.drawImage(this.image, this.x, this.y, this.image.width, this.image.height);
			};

			Explosion.prototype.draw = function() {
				// normal version
				//CONTEXT.drawImage(this.image, this.x, this.y, this.width, this.height);
				// animated version
				CONTEXT.drawImage(this.image, this.tickCount * 64, 0, this.width, this.height, this.x, this.y, this.width, this.height);
			};

			Explosion.prototype.update = function() {
				this.tickCount += 1;
				if (this.tickCount == this.maxFrames) {
					tickCount = 0;
				}

			};

			Player.prototype.getInfo = function() {
				return "x = " + this.x + ", y = " + this.y;
			};

			Player.prototype.fireMissile = function() {
				if (PLAYER.ammoRockets > 0) {
				 	let middleOfJet = PLAYER.x + (PLAYER.image.width / 2);
					var missile = new Missile(PLAYER.y + 47);
					if (ALTERNATE_MISSILE_WING == 0) { // left
						missile.x = middleOfJet - 25;
						ALTERNATE_MISSILE_WING = 1;
					} else if (ALTERNATE_MISSILE_WING == 1) { // right
						missile.x = ((middleOfJet + 25) - missile.image.width);
						ALTERNATE_MISSILE_WING = 0;
					}
					/*

					var missile = new Missile(PLAYER.y + 225);
					if (ALTERNATE_MISSILE_WING == 0) {
						missile.x = PLAYER.x - 20;
						ALTERNATE_MISSILE_WING = 1;
					} else if (ALTERNATE_MISSILE_WING == 1) {
						missile.x = PLAYER.x + 22;
						ALTERNATE_MISSILE_WING = 0;
					}
					   */

					MISSILES.push(missile);
					PLAYER.ammoRockets -= 1;
				}
			};

			// ## Events ##
			var Keys = {
				UP: false,
				LEFT: false,
				RIGHT: false,
				DOWN: false
			};

			window.onkeydown = function(e) {
				if (Boolean(PLAYER.alive)) {
					switch (e.keyCode) {
						case 87: 
							Keys.UP = true;
						break;
						case 65:
							Keys.LEFT = true;
						break;
						case 68:
							Keys.RIGHT = true;
						break;
						case 83:
							Keys.DOWN = true;
						break;
						case 32:
							PLAYER.fireMissile();
						break;
						case 73:
							alert("Player.x = " + PLAYER.x + ", Player.Y = " + PLAYER.y);
						break;
					}
				}
			}
			window.onkeyup = function(e) {
				if (Boolean(PLAYER.alive)) {
					switch (e.keyCode) {
						case 87: 
							Keys.UP = false;
						break;
						case 65:
							Keys.LEFT = false;
						break;
						case 68:
							Keys.RIGHT = false;
						break;
						case 83:
							Keys.DOWN = false;
						break;
					}
				}
			}

			window.onload = function() {
				init();
			}

			function init() {
				window.requestAnimationFrame(frame);
				drawTileArray();
			}

			function drawTileArray() {
				let tileSize = 50;
				let maxHorizontalTiles = CANVAS.width / tileSize;
				let maxVerticalTiles = CANVAS.height / tileSize;
				let maxTiles = maxVerticalTiles * maxHorizontalTiles;

				for (let i = 0; i < maxVerticalTiles; i++) {
					for (let a = 0; a < maxHorizontalTiles; a++) {
						CONTEXT.drawImage(TILE_WATER, (a * tileSize), (i * tileSize), tileSize, tileSize);
					}
				}
			}

			/*
			   ## First loop ##
			   1. LAST: record time since webpage loaded in this var (e.g. 35.86)
			   2. NOW: record time since program started in this var (e.g. 74.72)
			   3. frameDuration: A variable that now has the time it cost to go from frame 0 to frame 1(e.g. 74.72 - 35.86 = 38.86)
			   ## Second loop and all loops afterwards ##
			   1. LAST: record time since this frame occurred (e.g. 74.72)
			   2. Request a new frame
			   3. NOW: record time since program started in this var (e.g. 259.11)
			   4. frameDuration: A variable that now has the time it cost to go from frame 1 to frame 2(e.g. 259.11 - 74.72 = 38.86)
			   5. We now know how long the last frame took
				

		    */
			function frame() {
				NOW = timestamp();
				//alert(LAST + " " + NOW);
				var frameDuration  = NOW - LAST;
				COUNT += frameDuration;
				console.log("frameDuration: " + frameDuration + ", and COUNT: " + COUNT);
	 			//console.log(COUNT);
				//console.log("LAST: " + LAST + ", NOW:" + NOW + ", frameDuration:" + frameDuration);
				LAST = NOW;
				update(frameDuration);
				render(frameDuration);
				window.requestAnimationFrame(frame);
			}

			// Returns ms since program started
			function timestamp() {
				return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
			}

			function update(frameDuration) {
				GLOBAL_TIMER += frameDuration;
			 	FPS_COUNT += frameDuration;

				move();
				for (let i = 0; i < EXPLOSIONS.length; i++) {
					EXPLOSIONS[i].update();
				}

				/*
				for (let i = 0; i < MISSILES.length; i++) {
					MISSILES[i].update();
				}
				*/

				for (let i = 0; i < MISSILES.length; i++) {
					for (let a = 0; a < ENEMY_JETS.length; a++) {
						if (collision(MISSILES[i].x, MISSILES[i].y, ENEMY_JETS[a].x, ENEMY_JETS[a].y, MISSILES[i].image.width, MISSILES[i].image.height, (ENEMY_JETS[a].image.width + 5), ENEMY_JETS[a].image.height)) {
	 						var explosion = new Explosion(ENEMY_JETS[a].x, ENEMY_JETS[a].y);
							explosion.startTime = GLOBAL_TIMER;
	 						EXPLOSIONS.push(explosion);

							MISSILES.splice(i, 1);
							ENEMY_JETS.splice(a, 1);
							break; // If there are more jets, the missile gets removed but is expected to be there when the jet for loop goes to the second loop..
						}
					}
				}

				for (let i = 0; i < MISSILES.length; i++) {
					if (MISSILES[i].y < 0) {
						MISSILES.splice(i, 1);
					}
				}

				for (let i = 0; i < ENEMY_JETS.length; i++) {
					if (ENEMY_JETS[i].y > CANVAS.height) {
						ENEMY_JETS.splice(i, 1);
					}
				}

				if (Boolean(PLAYER.alive)) {
					for (let i = 0; i < ENEMY_JETS.length; i++) {
						if (collision(PLAYER.x, PLAYER.y, ENEMY_JETS[i].x, ENEMY_JETS[i].y, PLAYER.image.width, PLAYER.image.height, ENEMY_JETS[i].image.width, ENEMY_JETS[i].image.height)) {
							var explosion = new Explosion(ENEMY_JETS[i].x, ENEMY_JETS[i].y);
							explosion.startTime = GLOBAL_TIMER;
							EXPLOSIONS.push(explosion);

							var secondExplosion = new Explosion(PLAYER.x, PLAYER.y);
							secondExplosion.startTime = GLOBAL_TIMER;
							EXPLOSIONS.push(secondExplosion);
							ENEMY_JETS.splice(i, 1);
							PLAYER.alive = 0;
						}
					}
				}

				if (PLAYER.ammoRockets == 0) {
					reload();
				}

				for (let i = 0; i < EXPLOSIONS.length; i++) {
					if ((GLOBAL_TIMER - 1000) > EXPLOSIONS[i].startTime) {
						EXPLOSIONS.splice(i, 1);
					}
				}

				updateEnemies(frameDuration);
			}

			function render(frameDuration) {
				//console.log("if (" + COUNT + " >= 0.06)");
				// was 0.06
				if (COUNT >= 16.66) {
					drawTileArray();
					for (let i = 0; i < MISSILES.length; i++) {
						MISSILES[i].draw();
					}
					for (let i = 0; i < ENEMY_JETS.length; i++) {
						ENEMY_JETS[i].draw();
					}
					for (let i = 0; i < EXPLOSIONS.length; i++) {
						EXPLOSIONS[i].draw();
					}
					CONTEXT.fillText("FPS: " + TEMP_TOTAL_FRAMERATE, 2,25);


					if (PLAYER.ammoRockets != 0) {
						CONTEXT.fillText("ROCKETS: " + PLAYER.ammoRockets, 2, CANVAS.height - 4);
					} else {
						CONTEXT.fillText("ROCKETS: reloading", 2, CANVAS.height - 4);
					}

					// this is wrong...
					if(FPS_COUNT >= 1000) {
					    document.getElementById("debug").innerHTML = TOTAL_FRAMES;
						CONTEXT.fillText("FPS: " + TOTAL_FRAMES, 2,25);
						TEMP_TOTAL_FRAMERATE = TOTAL_FRAMES;
						TOTAL_FRAMES = 0;
						FPS_COUNT = 0;
					}

					if (Boolean(PLAYER.alive)) {
						PLAYER.draw();
					}

					COUNT = 0;

					if (!Boolean(PLAYER.alive)) {
						drawMenu();
					}

					TOTAL_FRAMES += 1;
				}
				CONTEXT.fillText(Math.floor(GLOBAL_TIMER), 1100, 25);
			 // document.getElementById("debug").innerHTML = Math.round(GLOBAL_TIMER);
			}

			function collision (entityOneX, entityOneY, entityTwoX, entityTwoY, entityOneWidth, entityOneHeight, entityTwoWidth, entityTwoHeight) {
				if (entityOneX < entityTwoX + entityTwoWidth &&
				   entityOneX + entityOneWidth > entityTwoX &&
				   entityOneY < entityTwoY + entityTwoHeight &&
				   entityOneHeight + entityOneY > entityTwoY) {
					return true;
				} else {
					return false;
				}
			}
			/*
			    // my solution
				if ((entityOneX >= entityTwoX) && 
			       ((entityOneX + entityOneWidth) <= (entityTwoX + entityTwoWidth)) &&
     			   (entityOneY <= (entityTwoY + entityTwoHeight)) &&
				   (entityOneY >= entityTwoY)) {
					return true;
				} else {
					return false;
				}

		    */

			function reload() {
				if (!Boolean(RELOADING)) {
					TIMER_STARTING_TIME = GLOBAL_TIMER;
					//console.log("STARTED: " + TIMER_STARTING_TIME);
					RELOADING = 1;
				}
				//console.log("if " + GLOBAL_TIMER + " > " + (TIMER_STARTING_TIME + 4000));
				//alert("triggered");
				if (GLOBAL_TIMER > (TIMER_STARTING_TIME + RELOAD_DURATION)) {
					PLAYER.ammoRockets = PLAYER.maxRockets;
					TIMER_STARTING_TIME = 0;
					RELOADING = 0;
				}
			}
			

			function updateEnemies (frameDuration) {
				for (let i = 0; i < ENEMY_JETS.length; i++) {
					ENEMY_JETS[i].y += ENEMY_JETS[i].speed;
					/*
					var randomSway = Math.floor(Math.random() * 3);
					if (randomSway == 0) {
						ENEMY_JETS[i].x += 1 ;
					} else if (randomSway == 1) {
						ENEMY_JETS[i].x -= 1;
					} 
					*/
				}
				// Uncomment to get more jets
				//if ((GLOBAL_TIMER > enemySpawnInterval) && ENEMY_JETS.length == 0) {
				if ((GLOBAL_TIMER > enemySpawnInterval)) {
					var enemy_jet = new EnemyJet((CANVAS.width / 2), CANVAS.height);
					var randomSpawnX = Math.floor(Math.random() * (CANVAS.width / 100));
					enemy_jet.x = randomSpawnX * 100;
					enemy_jet.y = -100;
					ENEMY_JETS.push(enemy_jet);
					// Uncomment to get more jets
					enemySpawnInterval += 2000;
				}
			}

			
			function drawMenu() {
				let menuSizeX = 500;
				let menuSizeY = 300;
				let menuPosX = ((CANVAS.width / 2) - (menuSizeX / 2));
				let menuPosY = ((CANVAS.height / 2) - (menuSizeY / 2));
				CONTEXT.strokeStyle = "white";
				CONTEXT.strokeRect(menuPosX, menuPosY, menuSizeX, menuSizeY);
				CONTEXT.stroke();

				CONTEXT.font = "123px Arial";
				CONTEXT.fillText("You died", menuPosX + 10, menuPosY + (menuSizeY / 2) + 35);
				CONTEXT.font = "30px Arial";
			}

			function move() {

				switch (Boolean(Keys)) {
					case Keys.UP && Keys.LEFT: // Northeast 
						if ((isInsideBounds(PLAYER.x, (PLAYER.y - PLAYER.speed))) && (isInsideBounds((PLAYER.x - PLAYER.speed), PLAYER.y))) {
							PLAYER.y -= PLAYER.speed;
							PLAYER.x -= PLAYER.speed;
						}
					break;
					case Keys.UP && Keys.RIGHT: // Northwest
						if ((isInsideBounds(PLAYER.x, (PLAYER.y - PLAYER.speed))) && (isInsideBounds((PLAYER.x + PLAYER.speed), PLAYER.y))) {
							PLAYER.y -= PLAYER.speed;
							PLAYER.x += PLAYER.speed;
						}
					break;
					case Keys.DOWN && Keys.LEFT: // Southeast 
						if ((isInsideBounds(PLAYER.x, (PLAYER.y + PLAYER.speed))) && (isInsideBounds((PLAYER.x - PLAYER.speed), PLAYER.y))) { 
							PLAYER.y += PLAYER.speed;
							PLAYER.x -= PLAYER.speed;
						}
					break;
					case Keys.DOWN && Keys.RIGHT: // Southwest 
						if ((isInsideBounds(PLAYER.x, (PLAYER.y + PLAYER.speed))) && (isInsideBounds((PLAYER.x + PLAYER.speed), PLAYER.y))) { 
							PLAYER.y += PLAYER.speed;
							PLAYER.x += PLAYER.speed;
						}
					break;
					case Keys.UP: // North 
						if (isInsideBounds(PLAYER.x, (PLAYER.y - PLAYER.speed)))
							PLAYER.y -= PLAYER.speed;
					break;
					case Keys.LEFT: // East 
						if (isInsideBounds((PLAYER.x - PLAYER.speed), PLAYER.y))
							PLAYER.x -= PLAYER.speed;
					break;
					case Keys.RIGHT: // West 
						if (isInsideBounds((PLAYER.x + PLAYER.speed), PLAYER.y))
							PLAYER.x += PLAYER.speed;
					break;
					case Keys.DOWN: // South 
						if (isInsideBounds(PLAYER.x, (PLAYER.y + PLAYER.speed)))
							PLAYER.y += PLAYER.speed;
					break;
				}

				for (let i = 0; i < MISSILES.length; i++) {
					MISSILES[i].y -= MISSILES[i].speed;
				}
			}

			function isInsideBounds(x, y) {
				if (y > (CANVAS.height - PLAYER.image.height)) { // prevent down
					return 0;
				} else if (x < 0) {
					return 0;
				} else if (x > (CANVAS.width - PLAYER.image.width)) {
					return 0;
				} else if (y < 0) {
					return 0;
				} else {
					return 1;
				}
			}

			/*
			   Player has a prototype object from which it inherits stuff
			   When instantiating from this class, a link is created to the original Player constructor class
			   Player is a prototype, the PLAYER var below inherits from the prototypeaPlayer has a prototype object from which it inherits stuffPlayer has a prototype object from which it inherits stuff
		    */

		</script>
	</body> 
</html>
